
[[dtmTable:jtagregisters]]
[cols="1,6,6",options="header"]
|===
|Address |Name |Description
|0x00 | BYPASS | JTAG recommends this encoding
|0x01 | IDCODE | To identify a specific silicon version
|0x10 | DTM Control and Status (`dtmcs`) | For Debugging
|0x11 | Debug Module Interface Access (`dmi`) | For Debugging
|0x12 | Reserved (BYPASS) | Reserved for future RISC-V debugging
|0x13 | Reserved (BYPASS) | Reserved for future RISC-V debugging
|0x14 | Reserved (BYPASS) | Reserved for future RISC-V debugging
|0x15 | Reserved (BYPASS) | Reserved for future RISC-V standards
|0x16 | Reserved (BYPASS) | Reserved for future RISC-V standards
|0x17 | Reserved (BYPASS) | Reserved for future RISC-V standards
|0x1f | BYPASS | JTAG requires this encoding
|===
==== ((`IDCODE`)) (at 0x01)

[[dtmIdcode]]
This register is selected (in IR) when the TAP state machine is reset.
Its definition is exactly as defined in IEEE Std 1149.1-2013.

This entire register is read-only.
[cols="3,10,1,1",options="header"]
|===
|Field |Description |Access |Reset
[[dtmIdcodeVersion]]
| ((Version))
| Identifies the release version of this part.
| R
| Preset
[[dtmIdcodePartnumber]]
| ((PartNumber))
| Identifies the designer's part number of this part.
| R
| Preset
[[dtmIdcodeManufid]]
| ((ManufId))
| Identifies the designer/manufacturer of this part. Bits 6:0 must be
            bits 6:0 of the designer/manufacturer's Identification Code as
            assigned by JEDEC Standard JEP106. Bits 10:7 contain the modulo-16
            count of the number of continuation characters (0x7f) in that same
            Identification Code.
| R
| Preset
|===

==== DTM Control and Status (((dtmcs)), at 0x10)

[[dtmDtmcs]]
The size of this register will remain constant in future versions so
that a debugger can always determine the version of the DTM.

[cols="3,10,1,1",options="header"]
|===
|Field |Description |Access |Reset
[[dtmDtmcsErrinfo]]
| ((errinfo))
| This optional field may provide additional detail about an error
            that occurred when communicating with a DM. It is updated whenever
            \FdtmDmiOp is updated by the hardware or when 1 is written to
            \FdtmDtmcsDmireset.

0 (not implemented): This field is not implemented.


1 (dmi error): There was an error between the DTM and DMI.


2 (communication error): There was an error between the DMI and a DMI subordinate.


3 (device error): The DMI subordinate reported an error.


4 (unknown): There is no error to report, or no further information available
                about the error. This is the reset value if the field is implemented.

Other values are reserved for future use by this specification.
| R
| 4
[[dtmDtmcsDtmhardreset]]
| ((dtmhardreset))
| Writing 1 to this bit does a hard reset of the DTM,
          causing the DTM to forget about any outstanding DMI transactions, and
          returning all registers and internal state to their reset value.
          In general this should only be used when the Debugger has
          reason to expect that the outstanding DMI transaction will never
          complete (e.g. a reset condition caused an inflight DMI transaction to
          be cancelled).
| W1
| -
[[dtmDtmcsDmireset]]
| ((dmireset))
| Writing 1 to this bit clears the sticky error state and resets
            \FdtmDtmcsErrinfo, but does not affect outstanding DMI transactions.
| W1
| -
[[dtmDtmcsIdle]]
| ((idle))
| This is a hint to the debugger of the minimum number of
            cycles a debugger should spend in
            Run-Test/Idle after every DMI scan to avoid a `busy'
            return code (\FdtmDtmcsDmistat of 3). A debugger must still
            check \FdtmDtmcsDmistat when necessary.

            0: It is not necessary to enter Run-Test/Idle at all.

            1: Enter Run-Test/Idle and leave it immediately.

            2: Enter Run-Test/Idle and stay there for 1 cycle before leaving.

            And so on.
| R
| Preset
[[dtmDtmcsDmistat]]
| ((dmistat))
| Read-only alias of \FdtmDmiOp.
| R
| 0
[[dtmDtmcsAbits]]
| ((abits))
| The size of \FdmSbaddressZeroAddress in \RdtmDmi.
| R
| Preset
[[dtmDtmcsVersion]]
| ((version))
| 

0 (0.11): Version described in spec version 0.11.


1 (1.0): Version described in spec versions 0.13 and 1.0.


15 (custom): Version not described in any available version of this spec.

| R
| 1
|===

==== Debug Module Interface Access (((dmi)), at 0x11)

[[dtmDmi]]
This register allows access to the Debug Module Interface (DMI).

In Update-DR, the DTM starts the operation specified in \FdtmDmiOp unless the
current status reported in \FdtmDmiOp is sticky.

In Capture-DR, the DTM updates \FdmSbdataZeroData with the result from that
operation, updating \FdtmDmiOp if the current \FdtmDmiOp isn't sticky.

See Section~\ref{dmiaccess} for examples of how this is used.

\begin{commentary}
The still-in-progress status is sticky to accommodate debuggers that
batch together a number of scans, which must all be executed or stop as
soon as there's a problem.

For instance a series of scans may write a Debug Program and execute
it.  If one of the writes fails but the execution continues, then the
Debug Program may hang or have other unexpected side effects.
\end{commentary}

[cols="3,10,1,1",options="header"]
|===
|Field |Description |Access |Reset
[[dtmDmiAddress]]
| ((address))
| Address used for DMI access. In Update-DR this value is used
            to access the DM over the DMI.
            \FdtmDmiOp defines what this register contains after every possible
            operation.
| R/W
| 0
[[dtmDmiData]]
| ((data))
| The data to send to the DM over the DMI during Update-DR, and
            the data returned from the DM as a result of the previous operation.
| R/W
| 0
[[dtmDmiOp]]
| ((op))
| When the debugger writes this field, it has the following meaning:

0 (nop): Ignore \FdmSbdataZeroData and \FdmSbaddressZeroAddress.

            Don't send anything over the DMI during Update-DR.
            This operation should never result in a busy or error response.
            The address and data reported in the following Capture-DR
            are undefined.

            This operation leaves the values in \FdtmDmiAddress and \FdtmDmiData
            \unspecified.


1 (read): Read from \FdtmDmiAddress.

            When this operation succeeds, \FdtmDmiAddress contains the address
            that was read from, and \FdtmDmiData contains the value that was
            read.


2 (write): Write \FdtmDmiData to \FdtmDmiAddress.

            This operation leaves the values in \FdtmDmiAddress and \FdtmDmiData
            \unspecified.


3 (reserved): Reserved.

When the debugger reads this field, it means the following:

0 (success): The previous operation completed successfully.


1 (reserved): Reserved.


2 (failed): A previous operation failed.  The data scanned into \RdtmDmi in
            this access will be ignored.  This status is sticky and can be
            cleared by writing \FdtmDtmcsDmireset in \RdtmDtmcs.

            This indicates that the DM itself or the DMI responded with an error.
            There are no specified cases in which the DM would
            respond with an error, and DMI is not required to support
            returning errors.

            If a debugger sees this status, there might be additional
            information in \FdtmDtmcsErrinfo.


3 (busy): An operation was attempted while a DMI request is still in
            progress. The data scanned into \RdtmDmi in this access will be
            ignored. This status is sticky and can be cleared by writing
            \FdtmDtmcsDmireset in \RdtmDtmcs. If a debugger sees this status, it
            needs to give the target more TCK edges between Update-DR and
            Capture-DR. The simplest way to do that is to add extra transitions
            in Run-Test/Idle.

| R/W
| 0
|===

==== ((`BYPASS`)) (at 0x1f)

[[dtmBypass]]
1-bit register that has no effect. It is used when a debugger does not
want to communicate with this TAP.

This entire register is read-only.

