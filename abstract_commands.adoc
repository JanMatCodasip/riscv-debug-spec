===== Access Register

[[Accessregister]]

This command gives the debugger access to CPU registers and allows it to
execute the Program Buffer. It performs the following sequence of
operations:

. If <<write>> is clear and <<transfer>> is set, then copy data from the register specified by <<regno>> into the `arg0` region of `data`, and perform any side effects that occur when this register is read from M-mode.
. If <<write>> is set and <<transfer>> is set, then copy data from the `arg0` region of `data` into the register specified by <<regno>>, and perform any side effects that occur when this register is written from M-mode.
. If <<aarpostincrement>> and <<transfer>> are set, increment <<regno>>. <<regno>> may also be incremented if <<aarpostincrement>>is set and <<transfer>> is clear.
. Execute the Program Buffer, if <<postexec>> is set.

If any of these operations fail, <<cmderr>> is set and none of the remaining steps
are executed. An implementation may detect an upcoming failure early,
and fail the overall command before it reaches the step that would cause
failure. If the failure is that the requested register does not exist in
the hart, <<cmderr>> must be set to 3 (exception).

Debug Modules must implement this command and must support read and
write access to all GPRs when the selected hart is halted. Debug Modules
may optionally support accessing other registers, or accessing registers
when the hart is running. It is recommended that if one register in a
group is accessible, then all registers in that group are accessible,
but each individual register (aside from GPRs) may be supported
differently across read, write, and halt status.

Registers might not be accessible if they wouldn't be accessible by M
mode code currently running. (E.g. `fflags` might not be accessible when
`mstatus`.latexmath:[$|FS|$] is 0.) If this is the case, the debugger is
responsible for changing state to make the registers accessible. The
Core Debug Registers (<<debreg>>) should be
accessible if abstract CSR access is implemented.

[NOTE]
====
The encoding of <<aarsize>> was chosen to match <,sbaccess>> in <<sbcs>>.
====
.Abstract Register Numbers
[%autowidth,float="center",align="center",cols=">,<",options="header"]
|===
|Numbers |Group Description
|0x0000 - 0x0fff | CSRs. The "PC" can be accessed here through <<dpc>>.
|0x1000 - 0x101f | GPRs
|0x1020 - 0x103f | Floating point registers
|0xc000 - 0xffff | Reserved for non-standard extensions and internal use.
|===

This command modifies `arg0` only when a register is read. The other
`data` registers are not changed.

include::images/datareg.edn[]

[[AccessregisterRegno]]
[float="center",align="center",cols="<1,<3",options="header"]
|===
|Field |Description
| `cmdtype`|This is 0 to indicate Access Register Command.
|[[aarsize]] `aarsize`
| 2 (32bit): Access the lowest 32 bits of the register. +
3 (64bit): Access the lowest 64 bits of the register. +
4 (128bit): Access the lowest 128 bits of the register.+
If <<aarsize,aarsize>> specifies a size larger than the register's actual size, then the access must fail. If a register is accessible, then reads of <<aarsize,aarsize>> less than or equal to the register's actual size must be supported. Writing less than the full register may be supported, but what happens to the high bits in that case is UNSPECIFIED. +
This field controls the Argument Width as referenced in <<datareg,datareg>>.
|[[aarpostincrement]] `aarpostincrement`
|0 (disabled): No effect. This variant must be supported. +
1 (enabled): After a successful register access, <<regno,regno>> is incremented.
Incrementing past the highest supported value causes <<regno,regno>> to become UNSPECIFIED.  Supporting this variant is optional. It is undefined whether the
increment happens when <<transfer,transfer>> is 0.
|[[postexec]] `postexec`
|0 (disabled): No effect. This variant must be supported, and is the only
supported one if <<progbufsize,progbufsize>> is 0. +
1 (enabled): Execute the program in the Program Buffer exactly once
after performing the transfer, if any. Supporting this variant is
optional.
|[[transfer]] `transfer`
|0 (disabled): Donâ€™t do the operation specified by <<write,write>>. +
1 (enabled): Do the operation specified by <<write,write>>. +
This bit can be used to just execute the Program Buffer without having
to worry about placing valid values into <<aarsize,aarsize>> or <<regno,regno>>.
|[[write]] `write`
|When <<transfer,transfer>> is set: +
0 (arg0): Copy data from the specified register into `arg0` portion of
`data`. +
1 (register): Copy data from `arg0` portion of `data` into the specified
register.
|[[regno]] `regno` |Number of the register to access, as described in <<regno,regno>>. <<dpc,dpc>> may be used as an alias for PC if this command is supported on a non-halted hart.
|===

===== Quick Access

[[acQuickaccess]]

Perform the following sequence of operations:

. If the hart is halted, the command sets <<cmderr,cmderr>> to "halt/resume" and does not continue.
. Halt the hart. If the hart halts for some other reason (e.g.
breakpoint), the command sets <<cmderr,cmderr> to "halt/resume" and does not continue.
. Execute the Program Buffer. If an exception occurs, <<cmderr,cmderr>> is set to "exception," the Program Buffer execution ends, and the hart is halted
with <<cause,cause>> set to 3.
. If the Program Buffer executed without an exception, then resume the
hart.

Implementing this command is optional.

This command does not touch the `data` registers.

include::images/qaccess.adoc[]

[[acQuickaccessCmdtype]]
[%autowidth,float="center",align="center",cols="<1,<2",options="header"]
|===
|Field |Description
|`cmdtype` | This is 1 to indicate Quick Access command.
|===

===== Access Memory

[[Accessmemory]]

This command lets the debugger perform memory accesses, with the exact
same memory view and permissions as the selected hart has. This includes
access to hart-local memory-mapped registers, etc. The command performs
the following sequence of operations:

. Copy data from the memory location specified in `arg1` into the `arg0`
portion of `data`, if <<write>> is clear.
. Copy data from the `arg0` portion of `data` into the memory location
specified in `arg1`, if <<write>> is set.
. If <<aampostincrement>> is set, increment `arg1`.

If any of these operations fail, <<cmderr>> is set and none of the remaining steps
are executed. An access may only fail if the hart, running M-mode code,
might encounter that same failure when it attempts the same access. An
implementation may detect an upcoming failure early, and fail the
overall command before it reaches the step that would cause failure.

Debug Modules may optionally implement this command and may support read
and write access to memory locations when the selected hart is running
or halted. If this command supports memory accesses while the hart is
running, it must also support memory accesses while the hart is halted.

[NOTE]
====
The encoding of <<aamsize>> was chosen to match <<sbaccess>> in <<sbcs>>.
====

This command modifies `arg0` only when memory is read. It modifies
`arg1` only if <<aampostincrement>> is set. The other `data` registers are not changed.

include::images/aam.adoc[float="center",align="center"]

[[acAccessmemoryTargetspecific]]
[align="center",float="center",cols="<1,<3",options="header"]
|===
|Field |Description
|[[acAccessmemoryCmdtype]] `cmdtype` |This is 2 to indicate Access Memory Command.
|[[acAccessmemoryAamvirtual]] `aamvirtual`| An implementation does not have to implement both virtual and accesses, but it must fail accesses that it doesn't support. +
0 (physical): Addresses are physical (to the hart they are performed
on). +
1 (virtual): Addresses are virtual, and translated the way they would be
from M-mode, with set. +
Debug Modules on systems without address translation (i.e. virtual
addresses equal physical) may optionally allow <<acAccessmemoryAamvirtual, aamvirtual>> set to 1, which would produce the same result as that same abstract command with <<acAccessmemoryAamvirtual, aamvirtual>> cleared.
|[[acAccessmemoryAamsize]] `aamsize`
|0 (8bit): Access the lowest 8 bits of the memory location. +
1 (16bit): Access the lowest 16 bits of the memory location. +
2 (32bit): Access the lowest 32 bits of the memory location. +
3 (64bit): Access the lowest 64 bits of the memory location. +
4 (128bit): Access the lowest 128 bits of the memory location.
|[[acAccessmemoryAampostincrement]] `aampostincrement`|
After a memory access has completed, if this bit is 1, increment `arg1`
(which contains the address used) by the number of bytes encoded in <<acAccessmemoryAamsize, aamsize>>.
Supporting this variant is optional, but highly recommended for
performance reasons.
|[[acAccessmemoryWrite]] `write`
|0 (arg0): Copy data from the memory location specified in `arg1` into
the low bits of `arg0`. The value of the remaining bits of `arg0` are UNSPECIFIED. +
1 (memory): Copy data from the low bits of `arg0` into the memory
location specified in `arg1`.
|[[target-specific]] `target-specific` |These bits are reserved for target-specific uses.
|===
